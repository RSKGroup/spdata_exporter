package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"strconv"
	"strings"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"gopkg.in/yaml.v2"
)

// Config represents the configuration file
type Config struct {
	Port      int      `yaml:"port"`
	DataTypes []string `yaml:"data_types"`
}

// PrometheusData represents the Prometheus-formatted data
type PrometheusData struct {
	Metric string
	Value  string
}

func main() {
	// Define flags
	configFile := flag.String("config", "systemprof_exporter.yml", "Path to the config file")
	flag.Parse()

	// Load the configuration file
	configData, err := os.ReadFile(*configFile)
	if err != nil {
		fmt.Println("Error reading the config file:", err)
		os.Exit(1)
	}
	// Parse the configuration file
	var config Config
	err = yaml.Unmarshal(configData, &config)
	if err != nil {
		fmt.Println("Error parsing the config file:", err)
		os.Exit(1)
	}

	// Map to store outputs for each data type
	dataTypeOutputs := make(map[string]string)

	// Get the system_profiler data requested from the configuration file
	for _, dataType := range config.DataTypes {
		// Run system_profiler
		cmd := exec.Command("system_profiler", "-json", dataType)
		// Store the output in a variable named after the dataType above
		dataTypeOutput, err := cmd.Output()
		if err != nil {
			fmt.Println("Error running system_profiler:", err)
			os.Exit(1)
		}
		// Store the output in the map
		dataTypeOutputs[dataType] = string(dataTypeOutput)
	}

	// Convert the JSON data to Prometheus format and expose it
	for dataType, output := range dataTypeOutputs {
		promOutput := jsonToPrometheus(output)
		fmt.Println(promOutput)
		registerPrometheusMetric(dataType, promOutput)
	}

	// Register Prometheus metrics handler
	http.Handle("/metrics", promhttp.Handler())

	// Start HTTP server to expose metrics
	addr := fmt.Sprintf(":%d", config.Port)
	fmt.Printf("Starting server on port %d\n", config.Port)
	err = http.ListenAndServe(addr, nil)
	if err != nil {
		fmt.Println("Error starting HTTP server:", err)
	}
}

// jsonToPrometheus takes a JSON string and returns a Prometheus-formatted string
func jsonToPrometheus(jsonData string) string {
	// Parse the JSON data into a map
	var data map[string][]map[string]interface{}
	if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
		fmt.Println("Error parsing JSON data:", err)
		return ""
	}
	// Construct Prometheus metric lines
	var prometheusData strings.Builder
	for dataType, objects := range data {
		for i, obj := range objects {
			traverseJSON(obj, i, dataType, "", &prometheusData)
		}
	}
	return prometheusData.String()
}

// traverseJSON traverses the JSON data and constructs Prometheus metric lines
func traverseJSON(data interface{}, index int, dataType, prefix string, prometheusData *strings.Builder) {
	switch v := data.(type) {
	case map[string]interface{}:
		for key, value := range v {
			switch value.(type) {
			case string:
				// Construct Prometheus metric line without using fmt.Sprintf to avoid escaped quotes
				prometheusData.WriteString("spdata_" + dataType + "_" + prefix + key + "{device=" + strconv.Itoa(index) + ", value=" + value.(string) + "} 1\n")
			case []interface{}:
				// If the value is an array, traverse each element recursively
				traverseJSON(value, index, dataType, prefix+key+"_", prometheusData)
			case map[string]interface{}:
				// If the value is a map, traverse it recursively
				traverseJSON(value, index, dataType, prefix+key+"_", prometheusData)
			}
		}
	case []interface{}:
		// If the data is an array, traverse each element recursively
		for _, item := range v {
			traverseJSON(item, index, dataType, prefix, prometheusData)
		}
	default:
		fmt.Printf("Unexpected type %T in JSON data\n", v)
	}
}

// registerPrometheusMetric registers a Prometheus gauge metric
func registerPrometheusMetric(dataType, promOutput string) {
	// Extract the metric name from the dataType
	metricName := strings.ReplaceAll(dataType, "SP", "")
	metricName = strings.ReplaceAll(metricName, "DataType", "")

	// Create a new gauge metric
	gauge := prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: fmt.Sprintf("spdata_%s", metricName),
			Help: "System profiler data",
		},
		[]string{"device", "name", "value"},
	)

	// Register the metric with the Prometheus registry
	prometheus.MustRegister(gauge)

	// Set metric values
	lines := strings.Split(promOutput, "\n")
	for _, line := range lines {
		if line != "" {
			// Parse the line to extract label values
			labels := parsePrometheusLabels(line)
			deviceLabel := labels["device"]
			valueLabel := labels["value"]
			// Include the metric name as a label
			gauge.WithLabelValues(deviceLabel, metricName, valueLabel).Set(1)
		}
	}
}

// extractLabelName extracts the label name from the first line of the promOutput
func extractLabelName(promOutput string) string {
	firstLine := strings.Split(promOutput, "\n")[0]
	if strings.Contains(firstLine, "{") {
		labelStart := strings.Index(firstLine, "{") + 1
		labelEnd := strings.Index(firstLine, "}")
		labels := strings.Split(firstLine[labelStart:labelEnd], ",")
		for _, label := range labels {
			if strings.Contains(label, "=") {
				// Split each label pair to get the key
				keyValue := strings.Split(label, "=")
				key := strings.TrimSpace(keyValue[0])
				// Return the key as the label name
				return key
			}
		}
	}
	return "" // Return an empty string if no label name is found
}

// parsePrometheusLabels extracts label values from a Prometheus-formatted string
func parsePrometheusLabels(line string) map[string]string {
	labels := make(map[string]string)
	labelStart := strings.Index(line, "{")
	labelEnd := strings.Index(line, "}")
	if labelStart != -1 && labelEnd != -1 {
		labelString := line[labelStart+1 : labelEnd]
		labelPairs := strings.Split(labelString, ",")
		for _, pair := range labelPairs {
			keyValue := strings.Split(pair, "=")
			if len(keyValue) == 2 {
				key := strings.TrimSpace(keyValue[0])
				value := strings.TrimSpace(keyValue[1])
				// Remove quotes if present
				value = strings.Trim(value, "\"")
				labels[key] = value
			}
		}
	}
	return labels
}
